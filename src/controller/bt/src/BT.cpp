// -------------------------------------------------------------------------------
// THIS FILE IS ORIGINALLY GENERATED BY THE DESIGNER.
// YOU ARE ONLY ALLOWED TO MODIFY CODE BETWEEN '///<<< BEGIN' AND '///<<< END'.
// PLEASE MODIFY AND REGENERETE IT IN THE DESIGNER FOR CLASS/MEMBERS/METHODS, ETC.
// -------------------------------------------------------------------------------

#include "behaviac_generated/types/behaviac_types.h"
#include <ros/ros.h>
#include "Agent1.h"
#include <ros/package.h>
#include <fsm/command_acc.h>
#include "behaviac_headers.h"

#include "iostream"

bool set_behavior_tree=true;
behaviac::Agent* g_MakeTreeAgent=NULL;

///<<< BEGIN WRITING YOUR CODE FILE_INIT

///<<< END WRITING YOUR CODE


//BT::BT()
//{
///<<< BEGIN WRITING YOUR CODE CONSTRUCTOR

///<<< END WRITING YOUR CODE
//}

//BT::~BT()
//{
///<<< BEGIN WRITING YOUR CODE DESTRUCTOR

///<<< END WRITING YOUR CODE
//}

//void BT::fly()
//{
///<<< BEGIN WRITING YOUR CODE 起飞
///<<< END WRITING YOUR CODE
//}


///<<< BEGIN WRITING YOUR CODE FILE_UNINIT

///<<< END WRITING YOUR CODE

//////////////////////////////////////////////////////////not me

//初始化加载
bool InitBehavic()
{
	// LOGI("InitBehavic\n");
	std::string package_path = ros::package::getPath("bt");
	std::string file_path = package_path + "/inc/exported";
	//behaviac::Workspace::GetInstance()->SetFilePath("../inc/exported");//行为树所在的目录
	behaviac::Workspace::GetInstance()->SetFilePath(file_path.c_str());//行为树所在的目录

	behaviac::Workspace::GetInstance()->SetFileFormat(behaviac::Workspace::EFF_xml);//加载的行为树格式（xml）

	return true;
}
//初始化实例
bool InitPlayer()
{
	ROS_INFO("InitPlayer");
	
	g_MakeTreeAgent = behaviac::Agent::Create<Agent1>();
	bool bRet = g_MakeTreeAgent->btload("FirstBT");
	g_MakeTreeAgent->btsetcurrent("FirstBT");
	// LOGI("InitPlayer finish\n");

	return bRet;
}

//执行行为树
void UpdateLoop()
{
	behaviac::EBTStatus status = behaviac::BT_RUNNING;
	while (status == behaviac::BT_RUNNING)
	{
                //behaviac::Workspace::GetInstance()->Update();
		 status = g_MakeTreeAgent->btexec();//循环节点在没有直到成功时会返回BT_RUNNING，此时继续执行此语句，让程序返回原先位置。
                //ROS_INFO("come on");
		ros::spinOnce();//进入回调函数
		ros::Duration(0.1).sleep();
	}

}


//销毁实例，释放工作区
static void CleanupPlayer()
{
	// LOGI("CleanupPlayer\n");

	g_MakeTreeAgent = NULL;
}

static void CleanupBehaviac()
{
	// LOGI("CleanupBehaviac\n");

	behaviac::Workspace::GetInstance()->Cleanup();
}

int main(int argc, char** argv)
{
	BEHAVIAC_UNUSED_VAR(argc);
	BEHAVIAC_UNUSED_VAR(argv);
	//init
    ros::init(argc, argv, "bt");
	
    ros::NodeHandle nh;
    //  Agent1   agent(nh);

    //ros::Publisher bt_waypoint = nh.advertise<fsm::command_acc>("/bt/fuck", 100);


	InitBehavic();
	InitPlayer();
    //logger.DEBUGINFO(g_BlackBoardAgent->car_id,"decision_node initialized!");
	ROS_INFO("BT initialized!");
	//Loop
	ros::Rate loop(20);

	int count = 0;
	//Agent1 agent;
	
	while(ros::ok()){
         //       UpdateLoop();
	//agent.pub();
		if(set_behavior_tree) 
		{
			// logger.DEBUGINFO(g_BlackBoardAgent->car_id,"ForegrdFunc Tree Start");
			UpdateLoop();
			// logger.DEBUGINFO(g_BlackBoardAgent->car_id,"ForegrdFunc Tree End");
			set_behavior_tree=false;
		}
        ros::spinOnce();
		loop.sleep();
    }
	 CleanupPlayer();

	CleanupBehaviac();
}


